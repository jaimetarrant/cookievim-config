" vim: set tw=78 nospell filetype=vim:
"
" Bundle specific sourcing and configuration
" ------------------------------------------
" This is a template for creating a new plugin config file for CookieVim.
"
" Bundle Repository {
" -------------------
" i.e.   Bundle 'github-user/repo'
"
Bundle 'kana/vim-operator-user'
Bundle 'rhysd/vim-clang-format'
Bundle 'Rip-Rip/clang_complete'

" }

" Configuration {
" ---------------
" Put plugin specific configuration info here:
"


" Disable neocomplete for C, C++

autocmd FileType c,c++,go " NeoCompleteLock

set autoindent
set cindent

" C syntax options
let c_syntax_for_h = 1
let c_C99 = 1
let c_warn_8bitchars = 1
let c_warn_multichar = 1
let c_warn_digraph = 1
let c_warn_trigraph = 1

" compiler stuff
let g:compiler_gcc_ignore_unmatched_lines=1
let mapleader=','
" quickfix :make
nmap <silent> <Leader>m :wa<CR>:silent! make \| redraw! \| cw<CR><CR>
vmap <silent> <Leader>m :wa<CR>:silent! make \| redraw! \| cw<CR><CR>
" handy shortcuts
map <Leader>h :ccl<CR>
map <Leader>s :cw<CR>
map <Leader>l :cl<CR>
" jump between messages
map <Leader>n :cn<CR>
map <Leader>p :cp<CR>

" @c comment, @u uncomment, @p print function name
let @u='0xx$xx^['
let @c='I/*^[A*/^['
let @p='ofprintf(stderr, "%s\n", __func__);^['


" Clang options

let g:clang_library_path='/usr/local/lib'
let g:syntastic_cpp_compiler = 'clang++'

let g:clang_format#style_options = {
            \ "AccessModifierOffset" : -4,
            \ "ColumnLimit" : 80,
            \ "AllowShortIfStatementsOnASingleLine" : "true",
            \ "AlwaysBreakTemplateDeclarations" : "true",
            \ "Standard" : "C++11"}

let g:clang_snippets = 1
let g:clang_snippets_engine = 'ultisnips'
let g:clang_close_preview = 1
let g:clang_auto_select = 1
set completeopt="menu,menuone,longest"
"let g:clang_auto_select=1
"let g:clang_complete_auto=1
let g:clang_complete_copen=1
"let g:clang_hl_errors=1
"let g:clang_periodic_quickfix=1
"let g:clang_snippets=1
"let g:clang_snippets_engine="clang_complete"
"let g:clang_conceal_snippets=1
let g:clang_exec="clang"
"let g:clang_user_options='2>/dev/null || exit 0'
let g:clang_auto_user_options="path, .clang_complete, obj/.clang_complete"
let g:clang_use_library=1
"let g:clang_sort_algo="priority"
"let g:clang_complete_macros=1
let g:clang_complete_patterns=1
nnoremap <Leader>q :call g:ClangUpdateQuickFix()<CR>

" map to <Leader>cf in C++ code
autocmd FileType c,cpp,objc nnoremap <buffer><Leader>cf :<C-u>ClangFormat<CR>
autocmd FileType c,cpp,objc vnoremap <buffer><Leader>cf :ClangFormat<CR>
" if you install vim-operator-user
autocmd FileType c,cpp,objc map <buffer><Leader>x <Plug>(operator-clang-format)

" Maybe improvements for OBSD ?
set cinoptions=t0,+4,(4,u4,w1
autocmd FileType c,cpp,objc set shiftwidth=4
autocmd FileType c,cpp,objc set softtabstop=4
autocmd FileType c,cpp,objc let c_space_errors=1

" Other Options
"
set tags=./tags;/

function! s:ExecuteInShell(command, bang)
    let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))

    if (_ != '')
        let s:_ = _
        let bufnr = bufnr('%')
        let winnr = bufwinnr('^' . _ . '$')
        silent! execute  winnr < 0 ? 'new ' . fnameescape(_) : winnr . 'wincmd w'
        setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap
        silent! :%d
        let message = 'Execute ' . _ . '...'
        call append(0, message)
        echo message
        silent! 2d | resize 1 | redraw
        silent! execute 'silent! %!'. _
        silent! execute 'resize ' . line('$')
        silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
        silent! execute 'autocmd BufEnter <buffer> execute ''resize '' .  line(''$'')'
        silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
        silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<CR>'
    endif
endfunction

command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
cabbrev shell Shell


" }
